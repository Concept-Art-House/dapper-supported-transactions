import NFTStorefront from ${NFTStorefrontContractAddress}
import DapperUtilityCoin from ${DapperUtilityCoinContractAddress}
import FungibleToken from ${FungibleTokenContractAddress}
import ${NFTContractName} from ${NFTContractAddress}

// This transaction checks if the authorizing account has a collection already. If not, we create a new empty
// collection and add it to the acccount.
transaction {
    prepare(userAcct: AuthAccount) {
        if userAcct.borrow<&${NFTContractName}.Collection>(from: ${NFTContractName}.CollectionStoragePath) == nil {
            let collection <- ${NFTContractName}.createEmptyCollection() as! @${NFTContractName}.Collection
            userAcct.save(<-collection, to: ${NFTContractName}.CollectionStoragePath)
            userAcct.link<&{${NFTContractName}.CollectionPublic}>(
                ${NFTContractName}.CollectionPublicPath,
                target: ${NFTContractName}.CollectionStoragePath,
            )
        }
    }
}
